Encapsulation. Wraps the related properties and methods that perform action on those properties in a class. For example, consider your mobile phone. It encapsulates a camera, display, memory cards, and several other hardware and software components. You don't have to worry about how components are wired internally.

Abstraction. An extension to encapsulation. The idea is to hide the internal implementation logic as much as possible. For example, to take a photo with your mobile phone, all you need to do is open the camera app, point your phone to the scene that you want to capture, and click a button to capture the photo. You don't need to know how the camera app is built or how the camera hardware on your mobile phone actually works. In short, the internal mechanics of the camera app and how a mobile camera captures the photos are abstracted to let you perform the tasks that matter.

Inheritance. Enables you to build a class upon the characteristics and behavior of other classes by establishing a parent-child relationship. For example, there are different manufacturers who produce a variety of mobile devices that run Android OS, but the UI for each of the devices is different. In other words, the manufacturers inherit the Android OS feature and build their customizations on top of it.

Polymorphism. The word is an adaptation of the Greek root poly-, which means many, and -morphism, which means forms. Polymorphism is the ability to use different objects in a single, common way. For example, when you connect a Bluetooth speaker to your mobile phone, the phone only needs to know that there's a device that can play audio over Bluetooth. However, there are a variety of Bluetooth speakers that you can choose from and your phone doesn't need to know how to work with each of them specifically.


Define a class
When you define a class, you specify the properties and methods that all objects of that class should have.


These are the recommended naming conventions for a class:

You can choose any class name that you want, but don't use Kotlin keywords(https://kotlinlang.org/docs/keyword-reference.html#hard-keywords) as a class name, such as the fun keyword.

The class name is written in PascalCase, so each word begins with a capital letter and there are no spaces between the words. For example, in SmartDevice, the first letter of each word is capitalized and there isn't a space between the words.



A class consists of three major parts:

Properties. Variables that specify the attributes of the class's objects.
Methods. Functions that contain the class's behaviors and actions.
Constructors. A special member function that creates instances of the class throughout the program in which it's defined.


Properties
Properties are basically variables that are defined in the class body instead of the function body. This means that the syntax to define properties and variables are identical. You define an immutable property with the val keyword and a mutable property with the var keyword.





Getter and setter functions in properties

When you don't define the getter and setter function for a property, the Kotlin compiler internally creates the functions. For example, if you use the var keyword to define a speakerVolume property and assign it a 2 value, the compiler autogenerates the getter and setter functions as you can see in this code snippet:

var speakerVolume = 2
    get() = field  
    set(value) {
        field = value    
    }


You won't see these lines in your code because they're added by the compiler in the background.

The full syntax for an immutable property has two differences:

It starts with the val keyword.
The variables of val type are read-only variables, so they don't have set() functions.


Kotlin properties use a backing field to hold a value in memory. A backing field is basically a class variable defined internally in the properties. A backing field is scoped to a property, which means that you can only access it through the get() or set() property functions.

To read the property value in the get() function or update the value in the set() function, you need to use the property's backing field. It's autogenerated by the Kotlin compiler and referenced with a field identifier.





Define a constructor
The primary purpose of the constructor is to specify how the objects of the class are created. In other words, constructors initialize an object and make the object ready for use. You did this when you instantiated the object. The code inside the constructor executes when the object of the class is instantiated. You can define a constructor with or without parameters.

Default constructor
A default constructor is a constructor without parameters. 


Kotlin aims to be concise, so you can remove the constructor keyword if there are no annotations or visibility modifiers, on the constructor. You can also remove the parentheses if the constructor has no parameters as shown in this code snippet:

class SmartDevice {
    ...
}


The Kotlin compiler autogenerates the default constructor. You won't see the autogenerated default constructor in your code because it's added by the compiler in the background.




Define a parameterized constructor

To maintain immutability but avoid hardcoded values, use a parameterized constructor to initialize them:

class SmartDevice(val name: String, val category: String) {}

The constructor now accepts parameters to set up its properties, so the way to instantiate an object for such a class also changes.

Note: If the class doesn't have a default constructor and you attempt to instantiate the object without arguments, the compiler reports an error.



There are two main types of constructors in Kotlin:

Primary constructor. A class can have only one primary constructor, which is defined as part of the class header. A primary constructor can be a default or parameterized constructor. The primary constructor doesn't have a body. That means that it can't contain any code.

Secondary constructor. A class can have multiple secondary constructors. You can define the secondary constructor with or without parameters. The secondary constructor can initialize the class and has a body, which can contain initialization logic. If the class has a primary constructor, each secondary constructor needs to initialize the primary constructor.



 The syntax to define a primary constructor starts with the class name followed by the constructor keyword and a set of parentheses. The parentheses contain the parameters for the primary constructor. If there's more than one parameter, commas separate the parameter definitions. 


The secondary constructor is enclosed in the body of the class and its syntax includes three parts:

Secondary constructor declaration. The secondary constructor definition starts with the constructor keyword followed by parentheses. If applicable, the parentheses contain the parameters required by the secondary constructor.

Primary constructor initialization. The initialization starts with a colon followed by the this keyword and a set of parentheses. If applicable, the parentheses contain the parameters required by the primary constructor.

Secondary constructor body. Initialization of the primary constructor is followed by a set of curly braces, which contain the secondary constructor's body.










